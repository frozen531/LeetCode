# 字符串常用解法

字符串经常与 **哈希表** ，**双指针** 一同使用，同时还有字符串的常用解法：

- 找规律
- 类似双指针的移动，找 **满足条件的一段连续相同字符** 

# [5. 最长回文子串](https://leetcode-cn.com/problems/longest-palindromic-substring/)

<font color = "blue"><strong>题目</strong></font>：

给定一个字符串，找到该字符串中最长的回文子串

```
示例 1：

输入: "babad"
输出: "bab"
注意: "aba" 也是一个有效答案。
示例 2：

输入: "cbbd"
输出: "bb"
```

<font color = "blue"><strong>代码</strong></font>：

```c++
class Solution {
public:
    string longestPalindrome(string s) {
        string res;
        
        for(int i = 0; i < s.size(); ++i)
        {
            int l = i - 1, r = i + 1;
            while(l >= 0 && r < s.size() && s[l] == s[r]) --l, ++r;
            if(res.size() < r - l - 1) res = s.substr(l + 1, r - l - 1); // (1)

            l = i, r = i + 1;
            while(l >= 0 && r < s.size() && s[l] == s[r]) --l, ++r;
            if(res.size() < r - l - 1) res = s.substr(l + 1, r - l - 1);
        }

        return res;
    }
};
```

<font color = "blue"><strong>易错点</strong></font>：

1. 由于是两边开花，先移动后判断，所以不包含两个边界，因此注意判断条件和子串起始值

# [6. Z 字形变换](https://leetcode-cn.com/problems/zigzag-conversion/)

<font color = "blue"><strong>题目</strong></font>：

输入字符串，将其按照Z字形排列，按行输出Z字形字符串。

```
输入: s = "LEETCODEISHIRING", numRows = 4
输出: "LDREOEIIECIHNTSG"
解释:

L     D     R
E   O E   I I
E C   I H   N
T     S     G
```

<font color = "blue"><strong>代码</strong></font>：

```c++
class Solution {
public:
    string convert(string s, int numRows) {
        string res;
        if(numRows == 1) return s; // (3)

        for(int row = 0; row < numRows; ++row)
        {
            if(row == 0)
                for(int index = 0; index < s.size(); index += 2 * (numRows - 1)) // (1)
                {
                    res += s[index];
                    cout << "enter" << endl;
                } 
            else if(row == numRows - 1)
                for(int index = row; index < s.size(); index += 2 * (numRows - 1)) res += s[index];
            else
                for(int first = row, second = 2 * (numRows - 1) - row; first < s.size(); first += 2 * (numRows - 1), second += 2 * (numRows - 1)) // (2)
                {
                    res += s[first];
                    if(second < s.size()) res += s[second];
                }
            
        }

        return res;
    }
};
```

<font color = "blue"><strong>易错点</strong></font>：

1. 规律性要找正确
2. 第一行和最后一行之间要加入两个元素，注意判断条件
3. 由于index递增时，是numRows-1，所以当仅有一行时需要特判，否则死循环

